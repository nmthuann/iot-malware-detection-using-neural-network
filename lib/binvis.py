import os
import string
import lib.scurve as scurve
import lib.scurve.utils as utils
import lib.scurve.draw as draw
import PIL.Image as Image
import PIL.ImageDraw as ImageDraw

class _Color:
    def __init__(self, data, block):
        self.data, self.block = data, block
        s = list(set(data))
        s.sort()
        self.symbol_map = {v : i for (i, v) in enumerate(s)}

    def __len__(self):
        return len(self.data)

    def point(self, x):
        if self.block and (self.block[0]<=x<self.block[1]):
            return self.block[2]
        else:
            return self.getPoint(x)


class ColorGradient(_Color):
    def getPoint(self, x):
        c = ord(self.data[x])/255.0
        return [
            int(255*c),
            int(255*c),
            int(255*c)
        ]


class ColorHilbert(_Color):
    def __init__(self, data, block):
        _Color.__init__(self, data, block)
        self.csource = scurve.fromSize("hilbert", 3, 256**3)
        self.step = len(self.csource)/float(len(self.symbol_map))

    def getPoint(self, x):
        c = self.symbol_map[self.data[x]]
        return self.csource.point(int(c*self.step))


class ColorClass(_Color):
    def getPoint(self, x):
        c = ord(self.data[x])
        if c == 0:
            return [0, 0, 0]
        elif c == 255:
            return [255, 255, 255]
        elif chr(c) in string.printable:
            return [55, 126, 184]
        return [228, 26, 28]


class ColorEntropy(_Color):
    def getPoint(self, x):
        e = utils.entropy(self.data, 32, x, len(self.symbol_map))
        # http://www.wolframalpha.com/input/?i=plot+%284%28x-0.5%29-4%28x-0.5%29**2%29**4+from+0.5+to+1
        def curve(v):
            f = (4*v - 4*v**2)**4
            f = max(f, 0)
            return f
        r = curve(e-0.5) if e > 0.5 else 0
        b = e**2
        return [
            int(255*r),
            0,
            int(255*b)
        ]


# def drawmap_unrolled(map, size, csource, name, prog): #original binvis function
def drawmap_unrolled(map, size, csource, name):
    # prog.set_target((size**2)*4)
    map = scurve.fromSize(map, 2, size**2)
    c = Image.new("RGB", (size, size*4))
    cd = ImageDraw.Draw(c)
    step = len(csource)/float(len(map)*4)

    # sofar = 0
    for quad in range(4):
        for i, p in enumerate(map):
            off = (i + (quad * size**2))
            color = csource.point(
                        int(off * step)
                    )
            x, y = tuple(p)
            cd.point(
                (x, y + (size * quad)),
                fill=tuple(color)
            )
            # if not sofar%100:
            #     prog.tick(sofar)
            # sofar += 1
    c.save(name)

# def drawmap_square(map, size, csource, name, prog): #original binvis function
def drawmap_square(map, size, csource, name):
    # prog.set_target((size**2))
    map = scurve.fromSize(map, 2, size**2)
    c = Image.new("RGB", map.dimensions())
    cd = ImageDraw.Draw(c)
    step = len(csource)/float(len(map))
    for i, p in enumerate(map):
        color = csource.point(int(i*step))
        cd.point(tuple(p), fill=tuple(color))
        # if not i%100:
        #     prog.tick(i)
    c.save(name)

def binvis(input_file_name,
            output_path = None,
            block = None, 
            color = 'entropy', 
            map = 'hilbert', 
            suffix = '',
            type = 'square',
            size = 256):
    with open(input_file_name, 'rb') as f:
        d = f.read()
        block = None

        base = os.path.basename(input_file_name)
        dst = base + suffix + ".png"

        if output_path is not None:
            if not os.path.exists(output_path):
                print("[!] Output path not found creating new one")
                os.mkdir(output_path)
            dst = output_path + dst

        if block:
            parts = block.split(":")
            if len(parts) not in [2, 3]:
                raise ValueError("Invalid block specification.")
            s, e = int(parts[0], 16), int(parts[1], 16)
            if len(parts) == 3:
                c = draw.parseColor(parts[2])
            else:
                c = [255, 0, 0]
            block = (s, e, c)

        if color == "class":
            csource = ColorClass(d, block)
        elif color == "hilbert":
            csource = ColorHilbert(d, block)
        elif color == "gradient":
            csource = ColorGradient(d, block)
        else:
            csource = ColorEntropy(d, block)

        if type == "unrolled":
            drawmap_unrolled(map, size, csource, dst)
        elif type == "square":
            drawmap_square(map, size, csource, dst)